In this project I have used styled-components. It encourages the creation of components with encapsulated styles, making the styling process more maintainable, scoped, and dynamic.

The bulk of the work was done in the Main component. The Main component provides a user interface to search for movies and filter them by genres, displaying a responsive list of movies based on the applied filters. It uses the useState and useEffect hooks to manage the state of movies, filtered movies and selected genres. The movie data is processed to create a simplified structure with titles, posters, and an array of genres for each movie.

The component includes a checkbox list for genres, and when a genre is selected or deselected, it triggers a change in the selectedGenres state. The handleGenreChange function toggles the boolean value of the selected genre in the state.

The handleFilter function is responsible for filtering movies based on the search input and selected genres. It filters the movies array, considering both the search query and the selected genres. If no genres are selected, it returns all movies. If at least one genre is selected, it filters movies based on whether they have at least one selected genre.

The biggest challenge that I faced was surrounding the filering logic. Initially, the filtering logic didn't account for the scenario where no genres were selected, resulting in no movies being displayed. The issue was addressed by modifying the handleFilter function to return true for all movies if no genres were selected. After applying filters and then clearing them, the movies weren't reverting to displaying all movies. To resolve this, the useEffect that updates filtered movies was adjusted to check whether the previous filtered movies were empty. If so, the filtered movies were set to be all movies, ensuring correct UI updates when filters are cleared.

Throught my project TypeScript interfaces were employed to define clear defintions for the structure of different data objects, providing benefits in terms of type safety and code documentation. For example, The RawMovie interface outlined the structure of raw movie data fetched from the external API. By specifying the expected structure, this interface facilitated type checking. Additionally, The SimplifiedMovie interface defined the structure of the simplified movie data used internally. As a result, clear property definitions made it easier to understand the available data and contributed to code maintainability.

When styling my components I adopted a mobile-first approach, this methodology aligns with the current trend of an increasingly mobile-centric user base, contributing to a responsive and user-friendly design. I also made sure to use semantic HTML in styled components which contributed to the clarity and accessibility of my code. This conveyed the meaning and structure of my components, making my code more understandable for developers and improving accessibility for users and assistive technologies such as screen readers.
